---
title: "Report, Missing Data"
subtitle: "ContDataQC"
author: "`r Sys.getenv('USERNAME')`"
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`"
output:
  html_document:
    toc: yes
    toc_depth: 3
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(results='asis', echo=FALSE, warning=FALSE)
# needed for trouble shooting
boo_DEBUG <- FALSE
boo_MakeData <- FALSE
if(boo_DEBUG == TRUE){
  
  # Config
  myConfig <- file.path(system.file(package="ContDataQC"), "extdata"
                        , "config.ORIG.R")
  source(myConfig)

  if(boo_MakeData == TRUE) {
    # Create Test Data
    Selection.Operation <- c("GetGageData"
                           , "QCRaw"
                           , "Aggregate"
                           , "SummaryStats")
    Selection.Type      <- c("Air","Water","AW","Gage","AWG","AG","WG")
    Selection.SUB <- c("Data0_Original"
                       , "Data1_RAW"
                       , "Data2_QC"
                       , "Data3_Aggregated"
                       , "Data4_Stats")
    (myDir.BASE <- tempdir()) # create and print temp directory for example data
    
    # Create data directories
    myDir.create <- file.path(myDir.BASE, Selection.SUB[1])
    ifelse(dir.exists(myDir.create) == FALSE
           , dir.create(myDir.create)
           , "Directory already exists")
    myDir.create <- file.path(myDir.BASE, Selection.SUB[2])
    ifelse(dir.exists(myDir.create) == FALSE
           , dir.create(myDir.create)
           , "Directory already exists")
    myDir.create <- file.path(myDir.BASE, Selection.SUB[3])
    ifelse(dir.exists(myDir.create) == FALSE
           , dir.create(myDir.create)
           , "Directory already exists")
    myDir.create <- file.path(myDir.BASE, Selection.SUB[4])
    ifelse(dir.exists(myDir.create) == FALSE
           , dir.create(myDir.create)
           , "Directory already exists")
    myDir.create <- file.path(myDir.BASE, Selection.SUB[5])
    ifelse(dir.exists(myDir.create) == FALSE
           , dir.create(myDir.create)
           , "Directory already exists")
    
    # Save example data (assumes myDir.BASE directory exists)
    myData <- data_raw_test2_AW_20130426_20130725
    write.csv(myData, file.path(myDir.BASE
                                , Selection.SUB[2]
                                , "test2_AW_20130426_20130725.csv"))
    myData <- data_raw_test2_AW_20130725_20131015
    write.csv(myData, file.path(myDir.BASE
                                , Selection.SUB[2]
                                , "test2_AW_20130725_20131015.csv"))
    myData <- data_raw_test2_AW_20140901_20140930
    write.csv(myData, file.path(myDir.BASE
                                , Selection.SUB[2]
                                , "test2_AW_20140901_20140930.csv"))
    myData <- data_raw_test4_AW_20160418_20160726
    write.csv(myData, file.path(myDir.BASE
                                , Selection.SUB[2]
                                , "test4_AW_20160418_20160726.csv"))
    myFile <- "config.TZ.Central.R"
    file.copy(file.path(path.package("ContDataQC"), "extdata", myFile)
              , file.path(myDir.BASE, Selection.SUB[2], myFile))
    
    
    # 02.A. QC Raw Data
    myData.Operation       <- "QCRaw" #Selection.Operation[2]
    myData.SiteID          <- "test2"
    myData.Type            <- Selection.Type[3] #"AW"
    myData.DateRange.Start <- "2013-01-01"
    myData.DateRange.End   <- "2014-12-31"
    myDir.import           <- file.path(myDir.BASE, Selection.SUB[2]) #"Data1_RAW"
    myDir.export           <- file.path(myDir.BASE, Selection.SUB[3]) #"Data2_QC"
    myReport.format        <- "docx"
    ContDataQC(myData.Operation
               , myData.SiteID
               , myData.Type
               , myData.DateRange.Start
               , myData.DateRange.End
               , myDir.import
               , myDir.export
               , fun.myReport.format = myReport.format)
    
    # 03. Aggregate Data
    myData.Operation       <- "Aggregate" #Selection.Operation[3]
    myData.SiteID          <- "test2"
    myData.Type            <- Selection.Type[3] #"AW"
    myData.DateRange.Start <- "2013-01-01"
    myData.DateRange.End   <- "2014-12-31"
    myDir.import           <- file.path(myDir.BASE, Selection.SUB[3]) #"Data2_QC"
    myDir.export           <- file.path(myDir.BASE, Selection.SUB[4]) #"Data3_Aggregated"
    #Leave off myReport.format and get default (docx).
    ContDataQC(myData.Operation
               , myData.SiteID
               , myData.Type
               , myData.DateRange.Start
               , myData.DateRange.End
               , myDir.import
               , myDir.export)
    #
      
  }## IF ~ boo_MakeData
  
  shell.exec(tempdir())
  
  # parameters for rest of RMD
  strFile <- "DATA_test2_Aw_20130101_20141231.csv"
  data.import <- read.csv(file.path(tempdir(), "Data3_Aggregated", strFile))

}
```

# DATA FILE INFORMATION

```{r data_file_info}
 # Report Info
  myReportDate <- format(Sys.Date(),ContData.env$myFormat.Date)
  cat(paste("**Report Date:** ",myReportDate,"\n\n",sep=""))
  myUser <- Sys.getenv("USERNAME")
  cat(paste("**Generated By:** ",myUser,"\n\n",sep=""))
  
  #filename
  cat("**Filename:** ",strFile,"\n\n",sep="")
  mySiteID <- data.import[1,ContData.env$myName.SiteID]
  
  cat(paste("**SiteID:** ",mySiteID,"\n\n",sep=""))
  
  if(exists("fun.myData.DateRange.Start")==TRUE){
    POR.Requested <- paste(fun.myData.DateRange.Start
                           ," to "
                           ,fun.myData.DateRange.End
                           , sep="")
  } else {
    POR.Requested <- "NA"
  }
  cat(paste("**Period of Record, Requested:** "
            ,POR.Requested,sep=""
            ,collapse="\n\n"))
  
  myNumRecords <- nrow(data.import) 
  # 20170228, mod from records 10 and 11 to half way point
  
  # myTimeDiff <- difftime(data.import[10,ContData.env$myName.DateTime]
  #,data.import[11,ContData.env$myName.DateTime],units="mins")
  #x <- data.import[,ContData.env$myName.DateTime]
  myT <- strptime(data.import[,ContData.env$myName.DateTime]
                  ,format=ContData.env$myFormat.DateTime)
  myTimeDiff.all <- difftime(myT[-1],myT[-length(myT)],units="mins")
  myTimeDiff <- median(as.vector(myTimeDiff.all),na.rm=TRUE)
  cat(paste("\n\n**Period of Record, Actual:**"
            ,min(data.import[,ContData.env$myName.Date])
            ," to "
            ,max(data.import[,ContData.env$myName.Date])
            ,"\n\n"
            ,sep=""))
       
  cat(paste("**Recording Interval (estimated):** "
            ,myTimeDiff[1]
            ," minutes\n\n"
            ,sep=""))
  
  if(exists("strFile.DataType")==TRUE){
    myDataType <- strFile.DataType
  } else {
    myDataType <- "NA"
  }
  cat(paste("**Data Type:** ",myDataType,"\n\n",sep=""))  # need to do better
  
   myParameters.ALL     <- ContData.env$myNames.DataFields[ContData.env$myNames.DataFields 
                                                           %in% names(data.import)==TRUE] 
   myParameters.Lab.ALL <- ContData.env$myNames.DataFields.Lab[ContData.env$myNames.DataFields 
                                                               %in% names(data.import)==TRUE]
   # Filter out Discrete
   myParameters     <- myParameters.ALL[!grepl(ContData.env$myPrefix.Discrete,myParameters.ALL)]
   myParameters.Lab <- myParameters.Lab.ALL[
                                           !grepl(ContData.env$myPrefix.Discrete
                                                   ,myParameters.Lab.ALL)]
   
   
 #cat("**Parameters:** ",paste(myParameters.Lab,", ",sep=""),"\n\n",sep="")
  # above line not working, preventing pandoc conversion to WORD
  #cat("**Included Parameters:** \n\n")
  cat("**Parameters Included:** ",paste(myParameters.ALL
                                        ,", "
                                        ,sep="")
      ,"\n\n"
      ,sep="")
```

# DATA SUMMARY, OVERALL

```{r data_summary_overall, results='asis',echo=FALSE, warning=FALSE}
#     2.1. Records by Month/Day
#     split so easier to put on paper
#     number of records by month/day (split 1:15 and 16:31)
#     
  # format = markdown/pandoc = seems to be the same.  All rows but no columns in Word.
  # Have to use on table not ftable.  ftable better by itself but doesn't work with knitr::kable.
    # # QC, if days less than count = 15
    #*Error in table.  Only printing half.* (fixed for sites with <15 days)
    # if((max(data.import[,"day"])-min(data.import[,"day"]))<15) {##IF.daycount.START
    #   myTable <- table(data.import[,"month"],data.import[,"day"])
    #   print(knitr::kable(myTable, format="markdown",row.names=TRUE))
    # } else {
    #   #
    #   #myTable.month.day.rec.LTE15 <-
    #   myTable <- table(data.import[,"month"][data.import[,"day"]<=15],data.import[,"day"][data.import[,"day"]<=15])
    #     print(knitr::kable(myTable, format="markdown", row.names=TRUE))
    #     #knitr::kable(myTable.month.day.rec.LTE15, format="pandoc", caption = "Title of the table")
    #   cat("\n\n")  
    #   #   
    #   # myTable.month.day.rec.GT15 <-
    #   myTable <- table(data.import[,"month"][data.import[,"day"]>15],data.import[,"day"][data.import[,"day"]>15])
    #     print(knitr::kable(myTable, format="markdown", row.names=TRUE))
      #   
   # }##IF.daycount.END
      # Convert time interval (minutes) to number per day
      records.expected <- round(24*60/as.numeric(myTimeDiff[1]),1)
      
      cat(paste("Estimated number of records per day is ",records.expected,".",sep=""))
        cat("\n\n")
        
    cat("Number of records by year and month (with totals).")
    cat("\n")
    myTable <- addmargins(table(data.import[,ContData.env$myName.Yr]
                                ,data.import[,ContData.env$myName.Mo]
                                , useNA = "ifany"))
        print(knitr::kable(myTable, format="markdown", row.names=TRUE))
    cat("\n\n")
    
  # revert to longer table (20170228)
    cat("Number of records by day and month (with totals).")
    cat("\n")
    myTable <- addmargins(table(data.import[,ContData.env$myName.Day]
                                ,data.import[,ContData.env$myName.Mo]
                                , useNA = "ifany"))
        print(knitr::kable(myTable, format="markdown", row.names=TRUE))
    cat("\n\n") 
#     
#     pandoc.table(myTable.month.day.rec.GT15,style="rmarkdown")
#    
#     
    myTable.month.day.rec <- table(data.import[,ContData.env$myName.Mo]
                                   ,data.import[,ContData.env$myName.Day]
                                   , useNA = "ifany")
#     use apply function to count number of records not equal to the expected value
    cat("\n\n")
    
    #
    myTable.DateTime.N <- aggregate(data.import[,ContData.env$myName.SiteID]  
                                    ~ data.import[,ContData.env$myName.DateTime]
                                    , data=data.import,FUN=length)
    # myTable <- myTable.DateTime.N[myTable.DateTime.N[,ContData.env$myName.SiteID]!=1,]
    # cat(paste0("Date and time records with more than one entry; N=",nrow(myTable),". Duplicate date.time records are shown below."))
    # cat("\n")
    #   print(knitr::kable(myTable, format="markdown", row.names=TRUE))
    # mask error, 20170307
    
    # Missing Dates
    
    myDateRange.Data <- seq(as.Date(min(data.import[,ContData.env$myName.Date]))
                            ,as.Date(max(data.import[,ContData.env$myName.Date]))
                            ,by="day")
    
    if(exists("fun.myData.DateRange.Start")==TRUE){
      myDateRange.Target <- seq(as.Date(fun.myData.DateRange.Start)
                              ,as.Date(fun.myData.DateRange.End)
                              ,by="day")
    } else {
      myDateRange.Target <- myDateRange.Data
    }
    
    myDateRange.Target.Missing <- myDateRange.Target[!myDateRange.Target %in% myDateRange.Data]
    cat(paste0("Below are the dates with missing data between the min (",min(myDateRange.Data)
               ,") and max(",max(myDateRange.Data)," for the provided data. There are "
               ,length(myDateRange.Target.Missing)," records."))
    cat("\n\n")
    print(ifelse(length(myDateRange.Target.Missing)==0,"",myDateRange.Target.Missing))
```

# FLAGS

```{r flags_legend}
cat(paste("* **",ContData.env$myFlagVal.Pass,"** = Pass,",sep=""))
cat("\n")
cat(paste("* **",ContData.env$myFlagVal.Suspect,"** = Suspect,",sep=""))  
cat("\n")
cat(paste("* **",ContData.env$myFlagVal.Fail,"** = Fail,",sep=""))
cat("\n")
cat(paste("* **",ContData.env$myFlagVal.NoData,"** = No Data or Not Applicable (NA).",sep=""))
```

Overall flags are assigned by examining the results of the four tests below. 

```{r flags_overall}
cat(paste("* **",ContData.env$myFlagVal.Pass,"** = no Fail or Suspect and at least one Pass,",sep=""))
cat("\n")
cat(paste("* **",ContData.env$myFlagVal.Suspect,"** = no Fail and at least one Suspect,",sep="")) 
cat("\n") 
cat(paste("* **",ContData.env$myFlagVal.Fail,"** = at least one Fail,",sep=""))
cat("\n")
cat(paste("* **",ContData.env$myFlagVal.NoData,"** = all tests were Missing Data.",sep=""))
```

Overall flags by parameter


(maybe combine into a single table)

```{r flags_parameters}
#
     for (j in 1:length(myParameters)) {##FOR.j.START
#       #
       #j.num <- match(j,myParameters)
 #   cat(paste(myParameters.Lab[j.num],"/n/n",sep=""))
       
       # ISSUE WITH knitr::kable INSIDE OF LOOPS
       
    cat(paste("## ",myParameters[j],"\n\n",sep=""))
       colnum <- match(paste("Flag",myParameters[j],sep="."),names(data.import))
       
       #print(myTable.Flags.Overall <- ftable(data.import[,colnum]))
       myTable <- addmargins(table(data.import[,colnum]
                                   , useNA = "ifany")
                             ,1)
       print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
       # future mod, 1,3,4,9 to Pass, Suspect, Fail, NA
       # exclude=NA to get all
       # future mod, 2nd line in table to include Percent of row total
       # future mod, sort levels
       
       cat("\n\n")
       
#       #
     }##FOR.j.END
```

# MISSING DATA, BY PARAMETER

Number of expected values could be estimated (see header info) but this 
would have to assume equal sampling effort in all cases.  This may not be the 
case for many data files.

Instead the number existing values will be shown in tabular and heat map format.
The user can then examine the information for instances of lower than expected
numbers of records.

```{r missing_data_parameters}
# 3. Data Info, by Parameter
    # Individual Data Type Report
    # QC
    i <- myParameters[1]
     for (i in myParameters) {##FOR.i.START
#       #
       i.num <- match(i,myParameters)
       myTitle.Sub <- myParameters.Lab[i.num]
       
       i.flag <- paste(ContData.env$myName.Flag, i, sep = ".")
       
      cat("## QC TESTS, ",i,"\n\n",sep="")
       
       #cat(paste("**QC TESTS,",myTitle.Sub,sep=""))
       
       # 3.1. Flags, overall
       cat(myTitle.Sub <- "### Flags")
             cat("\n\n")
      cat("#### Flag summary, overall number of records.")
      cat("\n\n")
       myTable <- addmargins(table(data.import[, i.flag]
                                   , useNA = "ifany")
                             ,1)
       print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
      
      cat("\n\n")
       
      #
      # 3.1. Number of Records (revised 20170228)
       # Convert time interval (minutes) to number per day
      records.expected <- round(24*60/as.numeric(myTimeDiff[1]),1)
      cat(paste("Estimated number of records per day is ",records.expected,".",sep=""))
      cat("\n\n")
      #
      cat("Number of records by year and month (with totals)")
      cat("\n")
      myTable <- addmargins(table(data.import[,ContData.env$myName.Yr]
                                  ,data.import[,ContData.env$myName.Mo]
                                  , useNA = "ifany"))
      print(knitr::kable(myTable, format="markdown", row.names=TRUE))
      cat("\n\n")
      #
      cat("Number of records by day and month (with totals)")
      cat("\n")
      myTable <- addmargins(table(data.import[,ContData.env$myName.Day]
                                  ,data.import[,ContData.env$myName.Mo]
                                  , useNA = "ifany"))
      #table, kable (static)
      #print(knitr::kable(myTable, format="markdown", row.names=TRUE))
      
      # table, DT (interactive)
      DT::datatable(as.data.frame.matrix(myTable)
                    , filter = "top"
                    , caption = "Records by day and month"
                    , options = list(scrollX = TRUE
                                     , scrollY = TRUE
                                     , lengthMenu = c(10, 20, 32)
                                     , autoWidth = TRUE
                                     ))
      
      
      
      cat("\n\n") 
      #
      # identify days/months where not the expected number of records
      # (expect first and last day)
  #    print("days where not the expected number of records")
      #
     
      #~~~~~~~~~~~~
      # New, 20220616
      # OTHER
      
      df_base <- data.import %>%
        dplyr::filter(!!as.name(i.flag) == "P") %>%
        dplyr::group_by(!!as.name(ContData.env$myName.MoDa)
                 , !!as.name(ContData.env$myName.Yr)) %>%
        dplyr::summarise(n = dplyr::n(), .groups = "drop")
      # munge
      df_base$MonthDay <- sprintf("%04d", df_base$MonthDay)
      # change class
      df_base$MonthDay <- as.character(df_base$MonthDay)
      df_base$Year <- as.character(df_base$Year)
      # Pivot
      df_plot <- tidyr::pivot_wider(df_base
                             , names_from = ContData.env$myName.Yr
                             , values_from = "n")
      
      cat("\n\n")
      #
      cat("Number of records by year and month for 'P'assing flags.")
      cat("\n\n")
      cat("Lower number of records are missing data or non-'P' flags.")
      cat("\n\n")
      
      # table, DT (interactive)
      # add color code (https://rstudio.github.io/DT/010-style.html)
      brks <- quantile(df_plot[, -1], probs = seq(.05, .95, .05), na.rm = TRUE)
      clrs <- round(seq(255, 40, length.out = length(brks) + 1), 0) %>%
                      {paste0("rgb(255,", ., ",", ., ")")}
      
      
      cat <- "Records by month-day and year"
      print(knitr::kable(df_plot, caption = cat))
      
      DT::datatable(df_plot
                    , filter = "top"
                    , caption = cat
                    , options = list(scrollX = TRUE
                                     , scrollY = TRUE
                                     , pageLength = 30
                                     , lengthMenu = c(15, 30, 60, 90, 120, 180, 366)
                                     , autoWidth = TRUE
                                     )) 
      # coloring doesn't look right
      # %>%
      #   formatStyle(names(df_plot)[-1]
      #                , backgroundColor = styleInterval(brks, clrs))
      # 
      cat("\n\n")
      
      # Plot, heat map
      str_title_hm <- paste0("Records with 'P'assing flags, ", mySiteID, ", ", i)
      p_hm <- ggplot2::ggplot(df_base
                              , ggplot2::aes(x = !!as.name(ContData.env$myName.Yr)
                                          , y = !!as.name(ContData.env$myName.MoDa)
                                          , fill = n)) +
        ggplot2::geom_tile() +
        ggplot2::scale_fill_gradient(low = "orange", high = "dark green") +
        ggplot2::labs(title = str_title_hm) +
        ggplot2::scale_y_discrete(limits = rev)
      # display as plotly
      print(p_hm)
      plotly::ggplotly(p_hm)

      
      # without plotly use
      #scale_y_discrete( guide = ggplot2::guide_axis(check.overlap = TRUE))
      
      
      cat("\n\n")
      
     }##FOR.i.END

```







